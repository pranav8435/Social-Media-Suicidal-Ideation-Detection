# Social-Media-Suicidal-Ideation-Detection

CS109 Challenge Project: Developing a Tool to Recognize Suicidal Ideation on Social Media Through Natural Language Processing

Introduction: According to the CDC, in 2019, more than 12 million Americans contemplated suicide. Among them, 1.4 million attempted to end their lives, and tragically, 47,500 individuals died by suicide. This issue has become so pervasive that the CDC has stated that suicide is the eleventh leading cause of death in the United States. After COVID-19, we’ve seen a sharp increase in social media usage—usage that has been linked to loneliness and depression, key risk factors that contribute to suicidal ideation and suicide. While social media can be incredibly detrimental to one’s mental health, it is also clear that social media is integral to modern society. However, what if there was a way to harness social media to combat mental health struggles rather than perpetuate them? What if the very platforms that frequently recommend content damaging to one’s psyche recognized the mental state of a user, guiding them towards the proper help they need if they need it? 

Project Goal: The goal of this project is to develop a tool capable of recognizing suicidal ideation through the online activity of a user, specifically, from what they post online. 

Methodology: To develop such a tool, I needed a dataset differentiating those with suicidal ideation and those without. Such a dataset was acquired from Mendeley Data. The dataset comprises Reddit posts from popular subreddits such as r/CasualConversation, r/BenignExistence, and r/CongratsLikeImFive, depicting non-suicidal text. Posts that were part of the class of suicidal ideation were from r/SuicideWatch, a subreddit composed of those struggling with suicidal intent and mental health issues as a whole. This dataset was composed of 15,477 records and posed a binary classification task, differentiating between non-suicidal and suicidal text. 

This dataset was purely composed of textual data, however, to train a machine learning model, I needed to represent these words as numerical values. This posed a significant task: how do I go about preprocessing such data? 

After researching online, I found standard preprocessing NLP techniques to remove noise from textual data, including tokenization and lemmatization. After having reduced noise from the dataset, I then needed to represent these representations as vectors for a machine learning model to be able to understand. Though I haven’t taken CS224N, I followed a link on the CS224N website to understand how I should go about doing so. I ended up using GloVe, a way to represent text through matrix factorization (something a bit beyond the scope of this class). However, to briefly describe what GloVe does, it essentially constructs a co-occurrence matrix from a given corpus to capture how often words appear together, then uses matrix factorization to reduce this data into a lower-dimensional embedding space. The result is a set of word vectors where similar words have similar representations. This set of words then needed to be aggregated into a singular value that would be understood by a machine-learning model, leading me to take the average of all the numerical representations in the word vector. 

However, simply having words be represented as numerical representations isn’t enough—it’s common when building machine learning algorithms to take in various features. This was seen in problem set 6 as well, where all the datasets used to train the Naive Bayes and Logistic Regression classifiers had multiple features, providing more information for the classification models to work with. To extract more features from the purely textual dataset, I decided to explore if the length of posts and sentiment of those posts would be drastically different for non-suicidal and suicidal text. After having run a bootstrapping algorithm that we designed in problem set 5, I found there to be a significant difference between the length of posts of those who struggled with suicidal ideation and those who didn’t (p-value < ~0.0001). Similarly, there was a significant difference between the sentiment of the posts written by those who had suicidal thoughts compared to those who didn’t (p-value < ~0.0001). This indicated that these features may be useful for the machine learning model to use, as there are large differences in the length and sentiment of posts written by those struggling with suicidal ideation compared to those who aren’t.

After having done all this feature extraction, it was time to design my classifier. While in class, we learned about naive Bayes and logistic regression, I found those models do not provide me with the best performance for the data I was dealing with. However, after a bit of research, I found the random forest algorithm to be well-suited for my dataset (in comparison to the other two models). While the random forest algorithm wasn’t covered in class, it leverages topics we discussed in class, as follows.

Intuition Behind the Random Forest Algorithm: A Random Forest is an algorithm that constructs a multitude of decision trees at training and outputs the class/label that is the mode of the classes/labels. In the algorithm, you specify the number of decision trees you would want, and each tree in the Random Forest generates a bootstrap sample of the training data (with replacement). Then, for each bootstrap sample, a decision tree is constructed. Each level of the decision tree selects a random subset of features to be used, and this process recursively keeps occurring until the decision tree is grown to the “stopping criterion” (such as the depth of the tree, which is specified in the algorithm’s implementation). After the trees have been made, each tree "votes" for a class, and the class with the most votes is assigned as the predicted class. 

Decision trees on their own are “weak learners,” however combining them with various other trees reduces the variability of the prediction of a single tree. This principle was also learned in class: the more trials we have of something, the lower the variance, as we become more certain about our outcome. Furthermore, the randomness induced by bootstrapping and random feature selection ensures that each decision tree in the ensemble is trained on a slightly different subset of the data and considers a different subset of features. This leads to the individual trees from being decorrelated, which 
prevents them from making the same errors.

In the case of my random forest model, I had 100 independent and identically distributed decision trees. This meant that each tree had the same level of bias, but due to the high number of trees being combined, the variance of all the trees combined decreased compared to an individual tree (more trials lead to less variance). Furthermore, during each decision tree’s creation, the tree was bootstrapping from my original dataset and randomly selected a size n subset of features from my dataset, where n refers to the number of features in my dataset (the reason why it is n is because that is what the inventors of the model recommended for classification tasks). This process keeps occurring, leading the decision tree to grow larger until it reaches a stop criterion.

One important note to mention is that the decision trees themselves are growing and repeating the bootstrapping method that I described earlier, they are continuously making splits based on the Gini index/Gini impurity during the model’s training phase. While Gini impurity goes beyond the scope of the class, it is important to random forest models as it generates the best split for each decision tree by analyzing how often a randomly chosen element from the dataset would be incorrectly labeled if it was randomly labeled according to the distribution of labels present in the tree’s current node. Essentially, at every node before the tree becomes bigger, the decision tree algorithm goes through all possible splits in the dataset and selects the split that results in the lowest Gini index. 

After the splits of the tree reach the specified maximum depth of the tree, the final nodes of the tree, (leaf nodes), contain the predictions. Each leaf node represents a subset of the data that falls into a specific class. The majority class within the leaf node is then assigned as the prediction for any new data points that reach that leaf during prediction (this is basically a counting problem: which class has a higher frequency by the time we reach the last split of the tree). This entire process occurred within my random forest model, where I specified the maximum depth of each decision tree to be 10 levels (usually recommended between 5 and 15 from what I saw online). Each tree recursively split according to the Gini index criterion while bootstrapping data and selecting random features. This process kept occurring until each tree reached its maximum depth. All these decision trees working together led my random forest model to have a train and test accuracy of 0.7867 and 0.7501 respectively.

Discussion and Impact: It’s no secret that social media has led to declining mental health, however, what if those platforms implemented such an algorithm to track the mental health of their users, recommend them beneficial resources and content while also employing mechanisms to discretely suggest a struggling user’s profile to loved ones who may have not reached out to them for an extended period of time. I believe that the social media platforms that design mental-health-based tools for their users would not only dramatically improve the lives of others, but also help them increase user satisfaction and retention with their products. This would recommend a systemic change from social media platforms that may not be realized fast enough, which is why I intend to currently work on my own solution. As of right now, I am extending this project by working on a journaling app that tracks users’ mental health through NLP-based machine-learning models and provides users’ therapists key information about their patient's mental health. This includes tracking user emotions over time and recognizing signs of suicidal ideation, anxiety, and depression, allowing therapists to further personalize their care. Additionally, I also recognize that my current machine learning model can be improved through more feature engineering and also through the implementation of deep learning models. 

Conclusion: Ultimately, suicide isn’t a problem that will magically disappear through the use of machine learning; however, I am a firm believer that if used correctly, we can recognize early signs that a person has been thinking about taking their own life. Algorithms like the one I developed are a step toward the right direction—a direction in which those struggling with their thoughts don’t end up acting on them. 

References:
Background Information: https://www.cdc.gov/suicide/facts/index.html <br />
Dataset found here: https://data.mendeley.com/datasets/z8s6w86tr3/1 <br />
Information about GloVe: https://vinija.ai/nlp/word-vectors/#overview-2 <br />
Information about Random Forest: https://www.cs.cmu.edu/~qyj/papersA08/11-rfbook.pdf


